---
title: "DS6306 Case Study 1"
author: "Rick Fontenot"
date: "12/20/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

For this case study we assume that our audience is the CEO and CFO of Budweiser (our client) and that they only have had one class in statistics. They have hired us to answer 7 questions and beyond those general questions we will speculate / anticipate what may be of interest to them.

We will start by importing the following data for analysis:

Beers.csv:
Name: Name of the beer.
Beer_ID: Unique identifier of the beer.
ABV: Alcohol by volume of the beer.
IBU: International Bitterness Units of the beer.
Brewery_ID: Brewery id associated with the beer.
Style: Style of the beer.
Ounces: Ounces of beer.

Breweries.csv:
Brew_ID: Unique identifier of the brewery.
Name: Name of the brewery.
City: City where the brewery is located.
State: U.S. State where the brewery is located.

```{r}
library(dplyr)
library(tidyverse)


beers = read.csv("https://raw.githubusercontent.com/rickfontenot/DS6306_Study1/main/Beers.csv", header = TRUE)

breweries = read.csv("https://raw.githubusercontent.com/rickfontenot/DS6306_Study1/main/Breweries.csv", header = TRUE)


head(beers)
head(breweries)

#install.packages("visdat")
library(visdat)
vis_dat(beers, warn_large_data=FALSE)
vis_dat(breweries, warn_large_data=FALSE)

dim(beers) #2410 observations x 7 columns
dim(breweries) #558 observations x 4 columns

sum(is.na(beers$Brewery_id)) #there are no missing values on the merge var
sum(is.na(breweries$Brew_ID)) #there are no missing values on the merge var

beers <- beers %>% rename(Beer_Name = Name) #both dataframes have "Name"
breweries <- breweries %>% rename(Brewery_Name = Name)

beerbrew <- merge(beers,breweries, by.x = "Brewery_id", by.y = "Brew_ID")
head(beerbrew)
 
head(beerbrew,6)
tail(beerbrew,6) # added to complete Question 2

beerbrew["Class"] <- ifelse(str_detect(beerbrew$Style,"IPA"),"IPA", ifelse(str_detect(beerbrew$Style,"Ale"),"Ale", ifelse(str_detect(beerbrew$Style,"Lager"),"Lager", ifelse(str_detect(beerbrew$Style,"Stout"),"Stout", ifelse(str_detect(beerbrew$Style,"Pilsner"),"Pilsner", ifelse(str_detect(beerbrew$Style,"Pilsener"),"Pilsner", ifelse(str_detect(beerbrew$Style,"Porter"),"Porter", ifelse(str_detect(beerbrew$Style,"APA"),"APA", ifelse(str_detect(beerbrew$Style,"Cider"),"Cider", ifelse(str_detect(beerbrew$Style,"Witbier"),"Witbier", ifelse(str_detect(beerbrew$Style,"Kölsch"),"Kölsch", ifelse(str_detect(beerbrew$Style,"Fruit"),"Fruit", ifelse(str_detect(beerbrew$Style,"Hefeweizen"),"Hefeweizen", ifelse(str_detect(beerbrew$Style,"Oktoberfest"),"Oktoberfest", ifelse(str_detect(beerbrew$Style,"Bitter"),"Bitter",
"Other")))))))))))))))

beerbrew %>%ggplot(aes(x = Class)) + geom_bar() +
ggtitle("Distribution of Styles") + coord_flip() + xlab("Style") + ylab("Count")

library(GGally)
beerbrew %>% select(ABV, IBU, Class) %>% ggpairs(aes(color=Class))

beerbrew %>% ggplot(mapping=aes(y=IBU, x=ABV,color=Class)) + geom_point(size=0.5, position="jitter")+ geom_smooth(method="lm",se=FALSE,size=1)+ labs(title="Correlation between ABV and IBU")
```


```{r, Joe's EDA}
#Joe EDA plotting on a map. 
#install.packages('usmap')
library(usmap)
```


```{r, Joe's EDA, Question 1}
#Question 1 How many Breweries are in each state

#table of number of Breweries by state
st.brew <- table(beerbrew$State)

#visualize that table
beerbrew %>% ggplot(aes(x=State),color=State) + 
  geom_histogram(binwidth = 5, stat="count") +
  theme(axis.text.x=element_text(angle=45,size = rel(.8), 
        margin = margin(.05, unit = "cm"),vjust =.5))
```

```{r, Jason's EDA, Question 3}
#Question 3 Address missing values in each col by dropping them
library(mice)
library(VIM)
beerbrew_drop <-beerbrew %>%
  na.omit()

#heatmap of missing values
md.pattern(beerbrew)

mice_plot <- aggr(beerbrew, col=c('navyblue','yellow'),
                  numbers=TRUE, sortVars=TRUE,
                  labels=names(beerbrew), cex.axis=.7,
                  gap=3, ylab=c("Missing data","Pattern"))

```

```{r, Joe's EDA, Question 3}
#Question 3 Address Missing values in each col

colSums(is.na(beerbrew))

#ABV has 62 missing values
#IBU has 1005 missing values 2410 total 
#no other NAs found
#it is likely that different state differ on their requirement to track IBU and ABV to operate within that state.
```


```{r, Joe's EDA, Compute Median by state ABV and IBU}
#Question 4 compute median median abv and ibu
#i'm making the choice to omit given 1005 or 2410 na values

st.ibu <- aggregate(IBU~State, data =  beerbrew, median, na.action=na.omit)
st.ibu

###visualize the state IBU median
st.ibu %>% ggplot(aes(x=State,y=IBU, fill=IBU)) + scale_fill_distiller(palette='Spectral') + geom_bar(stat = "identity") +
  theme(axis.text.x=element_text(angle=45,size = rel(.8), 
        margin = margin(.05, unit = "cm"),vjust =.5, hjust = 1))


#by date median ABV omitted na values
#Here it is practical to impute the missing values
st.abv <- aggregate(ABV~State, data = beerbrew, median, na.action = na.omit)
st.abv

#visualize the state abv medians
st.abv %>% ggplot(aes(x=State,y=ABV, fill=ABV)) + scale_fill_distiller(palette='Spectral') + geom_bar(stat = "identity") +
  theme(axis.text.x=element_text(angle=45,size = rel(.8), 
        margin = margin(.05, unit = "cm"),vjust =.5, hjust = 1))

#x is a table filtered for the missing abv values.
x <- beerbrew[!complete.cases(beerbrew$ABV),]

```
```{r Joe's EDA, Question 5 which state has the highest abv /ibu}

max.abv <- max(beerbrew$ABV,na.rm = T)
max.abv

max.ibu <- max(beerbrew$IBU, na.rm = T)
max.ibu

 

```

```{r Jason's EDA, Question 5 which state has the highest abv /ibu}
#alternate way
beerbrew[which.max(beerbrew$ABV),]
beerbrew[which.max(beerbrew$IBU),]
```




```{r Joe's EDA, Question 6 Comment on summary statistics distribution of ABV variable}


summary(beerbrew$ABV)

#Distribution of ABV Variable 
beerbrew %>% select(ABV) %>% ggplot(mapping=aes(x= ABV)) +
  geom_histogram(bins = 50) 

# Compare by State 
beerbrew %>% select(ABV, State) %>% ggplot(mapping=aes(x=ABV)) +
  geom_histogram(bins = 50) + facet_wrap(~State)
  

```

```{r Jason's EDA, Question 6 Start of Density plot by Beer Class}
p <- ggplot(beerbrew, aes(x=ABV)) + 
  geom_density()
p
```



```{r Joe's EDA, Question 7, Is there a relations between IBU and ABV}

beerbrew %>% ggplot(mapping=aes(y=IBU, x=ABV)) + geom_point()+
  geom_point(position=position_jitter(width=0.01),alpha=0.5)+
  geom_smooth(method="lm",se=FALSE,size=2)+
  labs(title="Correlation between ABV and IBU")


# correlation test

IbuAbv.cor <- cor.test(beerbrew$IBU,beerbrew$ABV, method= 'pearson')
IbuAbv.cor # cor test result 0.6706

```


```{r Jason's EDA, Question 7, Is there a relations between IBU and ABV}
library(ggpubr)
#7 Scatter Plot
#Feel free to remove

r_test = cor.test(beerbrew$IBU, beerbrew$ABV)
r_test

beerbrew.mod <- lm(IBU ~ ABV, data = beerbrew) 
summary(beerbrew.mod)

ggscatter(beerbrew, x = "IBU", y = "ABV", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "IBU", ylab = "ABV") +
  theme_economist()
```

```{r Jason's EDA, Question 8, KNN}
library(caret)
library(e1071)
library(class)
#Start of KNN
#Work in progress

# Filter out any beer style that is not an IPA or an Ale.
beers_IPAALE <- filter(beerbrew,grepl('IPA|Ale',Style))
beers_IPAALE <- beers_IPAALE[,-8]
# Create a new data frame that only holds the ABV,IBU, and beer style.
beers_IPAALE_sub <- select(beers_IPAALE,ABV,IBU,Style)
beers_IPAALE_sub$Style <- as.character(beers_IPAALE_sub$Style)

# Normalize the Beer styles to IPA or ALE
# This loop is used to iterate through each row and then to normalize the styles to simply say IPA or Ale.

for (i in 1:1534) {
  if (is.na(str_match(beers_IPAALE_sub[i,3],".Ale"))) {
    beers_IPAALE_sub[i,3] <- "IPA"
  } else {
    beers_IPAALE_sub[i,3] <- "ALE" 
    
  }
}


set.seed(877)
splitpale = .70
beerbrewsample <- sample(1:dim(beers_IPAALE_sub)[1],round(splitpale * dim(beers_IPAALE_sub)[1]))


# Test and Training with 70/30 split
knn_train <- beers_IPAALE_sub[beerbrewsample,]
knn_test <- beers_IPAALE_sub[-beerbrewsample,]

knn_train = na.omit(knn_train)
knn_test = na.omit(knn_test)

#md.pattern(knn_train)



# Using only the IBU and ABV values from both the training and test sets
# I use the beer style as the class against which the knn will search.
knnbeer <- knn(knn_train[,1:2],knn_test[,1:2],cl=knn_train$Style,k=24,prob = TRUE)
# The confusion matrix is used for calibrating the output of a model and examining all possible outcomes of the predictions
ipamatrix <- confusionMatrix(table(knnbeer,knn_test$Style))
ipamatrix

```


```{r Joe exploring ratio of breweries to NIH per capita consumption data}
per.capita <-  read.csv("https://github.com/rickfontenot/DS6306_Study1/raw/main/NIH_per_capita.csv", header = TRUE)
view(per.capita)


#Function to convert state FIPS codes to full state names or vice-versa [as factor levels for downstream grouping]:
#x is a vector of state abbreviations, or full state names.
#direction (name to code, or code to name) is determined automatically based on the supplied data
#depending on ultimate use of the returned set, 
#users may wish to retain factor levels for all states (default) or
#only those states for which data was passed to the function. factor levels (faclevs) should be indicated 'all' or 
#'selected' so as to return the desired state factors for downstream use default is to supply factor levels only for those states supplied in the dataset.

stateConversion <- function(x, faclevs = 'selected') {
  
  st.codes <- data.frame(state = as.factor(c("AK","AL","AR","AZ","CA","CO","CT","DC","DE", "FL", "GA", "HI","IA", "ID", "IL", "IN", "KS", "KY", "LA", "MA", "MD", "ME", "MI","MN","MO", "MS",  "MT", "NC", "ND", "NE", "NH", "NJ", "NM", "NV", "NY", "OH","OK", "OR", "PA", "PR", "RI", "SC", "SD", "TN", "TX", "UT", "VA", "VT","WA", "WI", "WV", "WY")),
  full = as.factor(c("Alaska","Alabama" ,  "Arkansas", "Arizona","California" , "Colorado" ,"Connecticut", "District of Columbia","Delaware" , "Florida" , "Georgia" , "Hawaii","Iowa" ,"Idaho" , "Illinois" , "Indiana" ,  "Kansas","Kentucky" , "Louisiana" , "Massachusetts", "Maryland" ,"Maine" ,"Michigan" , "Minnesota" , "Missouri" ,"Mississippi" ,  "Montana" ,"North Carolina","North Dakota", "Nebraska" , "New Hampshire" , "New Jersey" ,  "New Mexico" ,"Nevada" ,"New York" , "Ohio" , "Oklahoma" ,"Oregon" , "Pennsylvania" , "Puerto Rico", "Rhode Island" , "South Carolina", "South Dakota" ,"Tennessee" , "Texas" , "Utah","Virginia","Vermont","Washington" , "Wisconsin", "West Virginia" , "Wyoming")))
  
  if (nchar(x[1]) == 2) { st.x <- data.frame(state = x); refac.x <- st.codes$full[match(tolower(st.x$state), tolower(st.codes$state))] }
  else { st.x <- data.frame(full = x); refac.x <- st.codes$state[match(tolower(st.x$full), tolower(st.codes$full))] }
  
  if(faclevs == 'all') {return(refac.x)}
  else {return(factor(refac.x))}
  
}

#get state abbreviations IOT combine data sets using st. abrv as primary key
per.capita$st <- stateConversion(per.capita$State)
view(per.capita)

per.capita <- per.capita %>% rename(State_verbose = State,
                                    State = st)
#removing full state name
per.capita <- per.capita %>% select(-State_verbose)

head(per.capita)

#trimming extra space SHOUT OUT Rick for being a homey and finding this
brews.per.st$State <- trimws(brews.per.st$State)

#modify beerbrew IOT summarize number of breweries by state
brews.per.st <- beerbrew %>% group_by(State) %>% summarize(num.brews = n_distinct(Brewery_id))

#trimming extra space SHOUT OUT Rick for being a homey and finding this
brews.per.st$State <- trimws(brews.per.st$State)

#modify per.capita to unfactor states for joining data tables
per.capita %>% mutate_if(is.factor, as.character) -> per.capita


#join two data to compare per capita consumption to state breweries
brew.consum <- full_join(brews.per.st, per.capita, by= "State", Copy= TRUE)


#create ratio of gallons per capita to number of breweries

brew.consum <- brew.consum %>% mutate(per.capita.brewery.strength = 
                         Gallons.of.Ethanol.Per.Capita / num.brews) 

#create rankings based on the ration above
brew.consum <- brew.consum %>%
  mutate(per.capita.rank = dense_rank((desc(per.capita.brewery.strength))))

#ordering states for preparation for plotting
brew.consum <- brew.consum[order(brew.consum$State), ]

#needed to make column name lower case to mat usmaps library vector of states
brew.consum <- brew.consum %>% rename(state = State)

###density plot. May not be informative probably delete commented it out ###
#brew.consum %>% ggplot(aes(x=per.capita.brewery.strength)) +geom_density() 


#makeing a bar chart to help show which states have the most advantageous ratio
#creating filter at 0.5 leaves us with top 6                                      
brew.consum$filteredstate = ifelse(brew.consum$per.capita.brewery.strength > 0.5,brew.consum$state, "other")

#bar chart of top 6 most advantagous ratio
brew.consum %>% ggplot(aes(x=filteredstate, y = per.capita.brewery.strength)) +
  geom_bar(aes(fill= filteredstate),stat = "identity")


library(usmap)

ratio.map <- plot_usmap(data = brew.consum, values = "per.capita.brewery.strength",
           labels = FALSE, label_color = "white",  color ="black", alpha = 0.8,
           size = 1) + 
  scale_fill_continuous(low="blue", high = "red",
  name = "Breweries to Per capita consumption",
  label = scales::comma) + theme(legend.position = "bottom") +
  ggtitle("Under Represented States")

###        if we want state lables; set labels = TRUE 
#        and runs this code below for smaller labels. Helps with NE region  ###
#set label font size
#  ratio.map$layers[[2]]$aes_params$size <-2
#  print(ratio.map)
```
```{r, 2019 census data combined in }

library(dplyr)
library(stringr)
library(maps)
library(mapproj)

census2019 <-  read.csv("https://raw.githubusercontent.com/rickfontenot/DS6306_Study1/main/nst-est2019.csv", header = TRUE)

census2019 <- census2019[-c(1,2,3), ]

census2019 <- census2019 %>% rename('State' = "ï..table.with.row.headers.in.column.A.and.column.headers.in.rows.3.through.4...leading.dots.indicate.sub.parts.")

census2019 <- census2019 %>% rename("pop.2019" = "X.11")

census2019 <- subset(census2019, select = c("State", "pop.2019"))

census2019$State <- str_replace_all(census2019$State, "^\\.", "")

rownames(census2019) <- 1:nrow(census2019)

census2019 <- census2019[-c(1:5, 57:63), ]
head(census2019)
rownames(census2019) <- 1:nrow(census2019)

replaceCommas<-function(x){
  x<-as.numeric(gsub("\\,", "", x))
}

census2019$pop.2019 <- replaceCommas(census2019$pop.2019)

census2019$State <- state.abb[match(census2019$State, state.name)]

census2019$State[which(is.na(census2019$State))] <- "DC"

census2019 <- census2019 %>% rename("state" = "State")

brew.consum <- full_join(brew.consum, census2019, by = 'state')

brew.consum <- brew.consum %>% mutate(pop.adjusted.brewery.strength = 
                         pop.2019 * per.capita.brewery.strength) 


#see top 10 population adjusted brewery stength

top10 <- brew.consum %>% arrange(desc(pop.adjusted.brewery.strength)) %>% slice(1:10)

pop.adjusted <- plot_usmap(data = brew.consum, values = "pop.adjusted.brewery.strength",
           labels = FALSE, label_color = "white",  color ="black", alpha = 0.8,
           size = 1) + 
  scale_fill_continuous(low="blue", high = "red",
  name = "Population adjusted Brewery Strength",
  label = scales::comma) + theme(legend.position = "bottom") +
  ggtitle("Undere Represented States Adjusted for pop size")

pop.adjusted

top10 %>% ggplot(aes(x=reorder(state, -pop.adjusted.brewery.strength), y = pop.adjusted.brewery.strength)) +
  geom_bar(aes(fill= state),stat = "identity") + labs(title = "Population Adjusted Brewery Strength", x="Top 10 States", y = "State Brewery Strength * Total Pop" )

```